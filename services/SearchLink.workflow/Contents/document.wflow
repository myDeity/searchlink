<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>520</string>
	<key>AMApplicationVersion</key>
	<string>2.10</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.3</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict/>
					<key>CheckedForUserDefaultShell</key>
					<dict/>
					<key>inputMethod</key>
					<dict/>
					<key>shell</key>
					<dict/>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>#!/usr/bin/env ruby
# encoding: utf-8

SILENT = ENV['SL_SILENT'] =~ /false/i ? false : true
VERSION = '2.3.3'

# SearchLink by Brett Terpstra 2015 &lt;http://brettterpstra.com/projects/searchlink/&gt;
# MIT License, please maintain attribution
require 'net/https'
require 'uri'
require 'rexml/document'
require 'shellwords'
require 'yaml'
require 'cgi'
require 'fileutils'
require 'tempfile'
require 'zlib'
require 'time'
require 'json'
require 'erb'

if RUBY_VERSION.to_f &gt; 1.9
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end

PINBOARD_CACHE = File.expand_path('~/.searchlink_cache')

# Array helpers
class Array
  def longest_element
    group_by(&amp;:size).max.last[0]
  end
end

# String helpers
class ::String
  def slugify
    downcase.gsub(/[^a-z0-9_]/i, '-').gsub(/-+/, '-')
  end

  def slugify!
    replace slugify
  end

  def clean
    gsub(/\n+/, ' ')
      .gsub(/"/, '&amp;quot')
      .gsub(/\|/, '-')
      .gsub(/([&amp;?]utm_[scm].+=[^&amp;\s!,.)\]]++?)+(&amp;.*)/, '\2')
      .sub(/\?&amp;/, '').strip
  end

  # convert itunes to apple music link
  def to_am
    input = dup
    input.sub!(%r{/itunes\.apple\.com}, 'geo.itunes.apple.com')
    append = input =~ %r{\?[^/]+=} ? '&amp;app=music' : '?app=music'
    input + append
  end

  def path_elements
    path = URI.parse(self).path
    path.sub!(%r{/?$}, '/')
    path.sub!(%r{/[^/]+[.\-][^/]+/$}, '')
    path.gsub!(%r{(^/|/$)}, '')
    path.split(%r{/}).delete_if { |section| section =~ /^\d+$/ || section.length &lt; 5 }
  end

  def close_punctuation!
    replace close_punctuation
  end

  def close_punctuation
    return self unless self =~ /[“‘\[(&lt;]/

    words = split(/\s+/)

    punct_chars = {
      '“' =&gt; '”',
      '‘' =&gt; '’',
      '[' =&gt; ']',
      '(' =&gt; ')',
      '&lt;' =&gt; '&gt;'
    }

    left_punct = []

    words.each do |w|
      punct_chars.each do |k, v|
        left_punct.push(k) if w =~ /#{Regexp.escape(k)}/
        left_punct.delete_at(left_punct.rindex(k)) if w =~ /#{Regexp.escape(v)}/
      end
    end

    tail = ''
    left_punct.reverse.each { |c| tail += punct_chars[c] }

    gsub(/[^a-z)\]’”.…]+$/i, '...').strip + tail
  end

  def remove_seo!(url)
    replace remove_seo(url)
  end

  def remove_seo(url)
    title = dup
    url = URI.parse(url)
    host = url.hostname
    path = url.path
    root_page = path =~ %r{^/?$} ? true : false

    title.gsub!(/\s*(&amp;ndash;|&amp;mdash;)\s*/, ' - ')
    title.gsub!(/&amp;[lr]dquo;/, '"')
    title.gsub!(/&amp;[lr]dquo;/, "'")

    seo_title_separators = %w[| « - – · :]

    begin
      re_parts = []

      host_parts = host.sub(/(?:www\.)?(.*?)\.[^.]+$/, '\1').split(/\./).delete_if { |p| p.length &lt; 3 }
      h_re = !host_parts.empty? ? host_parts.map { |seg| seg.downcase.split(//).join('.?') }.join('|') : ''
      re_parts.push(h_re) unless h_re.empty?

      # p_re = path.path_elements.map{|seg| seg.downcase.split(//).join('.?') }.join('|')
      # re_parts.push(p_re) if p_re.length &gt; 0

      site_re = "(#{re_parts.join('|')})"

      dead_switch = 0

      while title.downcase.gsub(/[^a-z]/i, '') =~ /#{site_re}/i

        break if dead_switch &gt; 5

        seo_title_separators.each_with_index do |sep, i|
          parts = title.split(/ ?#{Regexp.escape(sep)} +/)

          next if parts.length == 1

          remaining_separators = seo_title_separators[i..-1].map { |s| Regexp.escape(s) }.join('')
          seps = Regexp.new("^[^#{remaining_separators}]+$")

          longest = parts.longest_element.strip

          unless parts.empty?
            parts.delete_if do |pt|
              compressed = pt.strip.downcase.gsub(/[^a-z]/i, '')
              compressed =~ /#{site_re}/ &amp;&amp; pt =~ seps ? !root_page : false
            end
          end

          title = if parts.empty?
                    longest
                  elsif parts.length &lt; 2
                    parts.join(sep)
                  elsif parts.length &gt; 2
                    parts.longest_element.strip
                  else
                    parts.join(sep)
                  end
        end
        dead_switch += 1
      end
    rescue StandardError =&gt; e
      return self unless $cfg['debug']
      warn 'Error processing title'
      p e
      raise e
      # return self
    end

    seps = Regexp.new("[#{seo_title_separators.map { |s| Regexp.escape(s) }.join('')}]")
    if title =~ seps
      seo_parts = title.split(seps)
      title = seo_parts.longest_element.strip if seo_parts.length.positive?
    end

    title &amp;&amp; title.length &gt; 5 ? title.gsub(/\s+/, ' ') : self
  end

  def truncate!(max)
    replace truncate(max)
  end

  def truncate(max)
    return self if length &lt; max

    max -= 3
    counter = 0
    trunc_title = ''

    words = split(/\s+/)
    while trunc_title.length &lt; max &amp;&amp; counter &lt; words.length
      trunc_title += " #{words[counter]}"
      break if trunc_title.length + 1 &gt; max

      counter += 1
    end

    trunc_title = words[0] if trunc_title.nil? || trunc_title.empty?

    trunc_title
  end

  def nil_if_missing
    return nil if self =~ /missing value/

    self
  end

  def split_hook
    elements = split(/\|\|/)
    {
      name: elements[0].nil_if_missing,
      url: elements[1].nil_if_missing,
      path: elements[2].nil_if_missing
    }
  end

  def split_hooks
    split(/\^\^/).map(&amp;:split_hook)
  end

  def matches_score(terms, separator: ' ', start_word: true)
    matched = 0
    regexes = terms.to_rx_array(separator: separator, start_word: start_word)

    regexes.each do |rx|
      matched += 1 if self =~ rx
    end

    (matched / regexes.count.to_f) * 10
  end

  def matches_exact(string)
    comp = gsub(/[^a-z0-9 ]/i, '')
    comp =~ /\b#{string.gsub(/[^a-z0-9 ]/i, '').split(/ +/).map { |s| Regexp.escape(s) }.join(' +')}/i
  end

  def matches_none(terms)
    terms.to_rx_array.each { |rx| return false if gsub(/[^a-z0-9 ]/i, '') =~ rx }
    true
  end

  def matches_any(terms)
    terms.to_rx_array.each { |rx| return true if gsub(/[^a-z0-9 ]/i, '') =~ rx }
    false
  end

  def matches_all(terms)
    terms.to_rx_array.each { |rx| return false unless gsub(/[^a-z0-9 ]/i, '') =~ rx }
    true
  end

  def to_rx_array(separator: ' ', start_word: true)
    bound = start_word ? '\b' : ''
    split(/#{separator}/).map { |arg| /#{bound}#{Regexp.escape(arg.gsub(/[^a-z0-9]/i, ''))}/i }
  end
end

# = plist
#
# Copyright 2006-2010 Ben Bleything and Patrick May
# Distributed under the MIT License
module Plist ; end

# === Load a plist file
# This is the main point of the library:
#
#   r = Plist::parse_xml( filename_or_xml )
module Plist
  def Plist::parse_xml( filename_or_xml )
    listener = Listener.new
    parser = StreamParser.new(filename_or_xml, listener)
    parser.parse
    listener.result
  end

  class Listener
    attr_accessor :result, :open

    def initialize
      @result = nil
      @open = Array.new
    end

    def tag_start(name, attributes)
      @open.push PTag::mappings[name].new
    end

    def text( contents )
      @open.last.text = contents if @open.last
    end

    def tag_end(name)
      last = @open.pop
      if @open.empty?
        @result = last.to_ruby
      else
        @open.last.children.push last
      end
    end
  end

  class StreamParser
    def initialize( plist_data_or_file, listener )
      if plist_data_or_file.respond_to? :read
        @xml = plist_data_or_file.read
      elsif File.exists? plist_data_or_file
        @xml = File.read( plist_data_or_file )
      else
        @xml = plist_data_or_file
      end

      @listener = listener
    end

    TEXT       = /([^&lt;]+)/
    XMLDECL_PATTERN = /&lt;\?xml\s+(.*?)\?&gt;*/um
    DOCTYPE_PATTERN = /\s*&lt;!DOCTYPE\s+(.*?)(\[|&gt;)/um
    COMMENT_START = /\A&lt;!--/u
    COMMENT_END = /.*?--&gt;/um

    def parse
      plist_tags = PTag::mappings.keys.join('|')
      start_tag  = /&lt;(#{plist_tags})([^&gt;]*)&gt;/i
      end_tag    = /&lt;\/(#{plist_tags})[^&gt;]*&gt;/i

      require 'strscan'

      @scanner = StringScanner.new(@xml)
      until @scanner.eos?
        if @scanner.scan(COMMENT_START)
          @scanner.scan(COMMENT_END)
        elsif @scanner.scan(XMLDECL_PATTERN)
        elsif @scanner.scan(DOCTYPE_PATTERN)
        elsif @scanner.scan(start_tag)
          @listener.tag_start(@scanner[1], nil)
          if (@scanner[2] =~ /\/$/)
            @listener.tag_end(@scanner[1])
          end
        elsif @scanner.scan(TEXT)
          @listener.text(@scanner[1])
        elsif @scanner.scan(end_tag)
          @listener.tag_end(@scanner[1])
        else
          raise "Unimplemented element"
        end
      end
    end
  end

  class PTag
    @@mappings = { }
    def PTag::mappings
      @@mappings
    end

    def PTag::inherited( sub_class )
      key = sub_class.to_s.downcase
      key.gsub!(/^plist::/, '' )
      key.gsub!(/^p/, '')  unless key == "plist"

      @@mappings[key] = sub_class
    end

    attr_accessor :text, :children
    def initialize
      @children = Array.new
    end

    def to_ruby
      raise "Unimplemented: " + self.class.to_s + "#to_ruby on #{self.inspect}"
    end
  end

  class PList &lt; PTag
    def to_ruby
      children.first.to_ruby if children.first
    end
  end

  class PDict &lt; PTag
    def to_ruby
      dict = Hash.new
      key = nil

      children.each do |c|
        if key.nil?
          key = c.to_ruby
        else
          dict[key] = c.to_ruby
          key = nil
        end
      end

      dict
    end
  end

  class PKey &lt; PTag
    def to_ruby
      CGI::unescapeHTML(text || '')
    end
  end

  class PString &lt; PTag
    def to_ruby
      CGI::unescapeHTML(text || '')
    end
  end

  class PArray &lt; PTag
    def to_ruby
      children.collect do |c|
        c.to_ruby
      end
    end
  end

  class PInteger &lt; PTag
    def to_ruby
      text.to_i
    end
  end

  class PTrue &lt; PTag
    def to_ruby
      true
    end
  end

  class PFalse &lt; PTag
    def to_ruby
      false
    end
  end

  class PReal &lt; PTag
    def to_ruby
      text.to_f
    end
  end

  require 'date'
  class PDate &lt; PTag
    def to_ruby
      DateTime.parse(text)
    end
  end

  require 'base64'
  class PData &lt; PTag
    def to_ruby
      data = Base64.decode64(text.gsub(/\s+/, ''))

      begin
        return Marshal.load(data)
      rescue Exception =&gt; e
        io = StringIO.new
        io.write data
        io.rewind
        return io
      end
    end
  end
end

module Plist
  VERSION = '3.1.0'
end

# Main SearchLink class
class SearchLink
  include Plist

  attr_reader :originput, :output, :clipboard

  attr_accessor :cfg

  # Values found in ~/.searchlink will override defaults in
  # this script

  def initialize(opt = {})
    @printout = opt[:echo] || false
    unless File.exist? File.expand_path('~/.searchlink')
      default_config = &lt;&lt;~ENDCONFIG
        # set to true to have an HTML comment included detailing any errors
        # Can be disabled per search with `--d`, or enabled with `++d`.
        debug: true
        # set to true to have an HTML comment included reporting results
        report: true

        # use Notification Center to display progress
        notifications: false

        # when running on a file, back up original to *.bak
        backup: true

        # change this to set a specific country for search (default US)
        country_code: US

        # set to true to force inline Markdown links. Can be disabled
        # per search with `--i`, or enabled with `++i`.
        inline: false

        # set to true to include a random string in reference titles.
        # Avoids conflicts if you're only running on part of a document
        # or using SearchLink multiple times within a document
        prefix_random: true

        # set to true to add titles to links based on the page title
        # of the search result. Can be disabled per search with `--t`,
        # or enabled with `++t`.
        include_titles: false

        # confirm existence (200) of generated links. Can be disabled
        # per search with `--v`, or enabled with `++v`.
        validate_links: false

        # If the link text is left empty, always insert the page title
        # E.g. [](!g Search Text)
        empty_uses_page_title: false

        # Formatting for social links, use %service%, %user%, and %url%
        # E.g. "%user% on %service%" =&gt; "ttscoff on Twitter"
        #      "%service%/%user%" =&gt; "Twitter/ttscoff"
        #      "%url%" =&gt; "twitter.com/ttscoff"
        social_template: "%service%/%user%"

        # append affiliate link info to iTunes urls, empty quotes for none
        # example:
        # itunes_affiliate: "&amp;at=10l4tL&amp;ct=searchlink"
        itunes_affiliate: "&amp;at=10l4tL&amp;ct=searchlink"

        # to create Amazon affiliate links, set amazon_partner to your amazon
        # affiliate tag
        #    amazon_partner: "bretttercom-20"
        amazon_partner: "bretttercom-20"

        # To create custom abbreviations for Google Site Searches,
        # add to (or replace) the hash below.
        # "abbreviation" =&gt; "site.url",
        # This allows you, for example to use [search term](!bt)
        # as a shortcut to search brettterpstra.com (using a site-specific
        # Google search). Keys in this list can override existing
        # search trigger abbreviations.
        #
        # If a custom search starts with "http" or "/", it becomes
        # a simple replacement. Any instance of "$term" is replaced
        # with a URL-escaped version of your search terms.
        # Use $term1, $term2, etc. to replace in sequence from
        # multiple search terms. No instances of "$term" functions
        # as a simple shortcut. "$term" followed by a "d" lowercases
        # the replacement. Use "$term1d," "$term2d" to downcase
        # sequential replacements (affected individually).
        # Long flags (e.g. --no-validate_links) can be used after
        # any url in the custom searches.
        #
        # Use $terms to slugify all search terms, turning
        # "Markdown Service Tools" into "markdown-service-tools"
        custom_site_searches:
          bt: brettterpstra.com
          btt: https://brettterpstra.com/topic/$term1d
          bts: /search/$term --no-validate_links
          md: www.macdrifter.com
          ms: macstories.net
          dd: www.leancrew.com
          spark: macsparky.com
          man: http://man.cx/$term
          dev: developer.apple.com
          nq: http://nerdquery.com/?media_only=0&amp;query=$term&amp;search=1&amp;category=-1&amp;catid=&amp;type=and&amp;results=50&amp;db=0&amp;prefix=0
          gs: http://scholar.google.com/scholar?btnI&amp;hl=en&amp;q=$term&amp;btnG=&amp;as_sdt=80006
        # Remove or comment (with #) history searches you don't want
        # performed by `!h`. You can force-enable them per search, e.g.
        # `!hsh` (Safari History only), `!hcb` (Chrome Bookmarks only),
        # etc. Multiple types can be strung together: !hshcb (Safari
        # History and Chrome bookmarks).
        history_types:
        - chrome_history
        - chrome_bookmarks
        - safari_bookmarks
        - safari_history
        - firefox_bookmarks
        - firefox_history
        - edge_bookmarks
        - edge_history
        - brave_bookmarks
        - brave_history
        # Pinboard search
        # You can find your api key here: https://pinboard.in/settings/password
        pinboard_api_key: ''

      ENDCONFIG

      File.open(File.expand_path('~/.searchlink'), 'w') do |f|
        f.puts default_config
      end
    end

    @cfg = YAML.load_file(File.expand_path('~/.searchlink'))

    # set to true to have an HTML comment inserted showing any errors
    @cfg['debug'] ||= false

    # set to true to get a verbose report at the end of multi-line processing
    @cfg['report'] ||= false

    @cfg['backup'] = true unless @cfg.key? 'backup'

    # set to true to force inline links
    @cfg['inline'] ||= false

    # set to true to add titles to links based on site title
    @cfg['include_titles'] ||= false

    # set to true to use page title as link text when empty
    @cfg['empty_uses_page_title'] ||= false

    # change this to set a specific country for search (default US)
    @cfg['country_code'] ||= 'US'

    # set to true to include a random string in ref titles
    # allows running SearchLink multiple times w/out conflicts
    @cfg['prefix_random'] = false unless @cfg['prefix_random']

    @cfg['social_template'] ||= '%service%/%user%'

    # append affiliate link info to iTunes urls, empty quotes for none
    # example:
    # $itunes_affiliate = "&amp;at=10l4tL&amp;ct=searchlink"
    @cfg['itunes_affiliate'] ||= '&amp;at=10l4tL&amp;ct=searchlink'

    # to create Amazon affiliate links, set amazon_partner to your amazon
    # affiliate tag
    #    amazon_partner: "bretttercom-20"
    @cfg['amazon_partner'] ||= ''

    # To create custom abbreviations for Google Site Searches,
    # add to (or replace) the hash below.
    # "abbreviation" =&gt; "site.url",
    # This allows you, for example to use [search term](!bt)
    # as a shortcut to search brettterpstra.com. Keys in this
    # hash can override existing search triggers.
    @cfg['custom_site_searches'] ||= {
      'bt' =&gt; 'brettterpstra.com',
      'imdb' =&gt; 'imdb.com'
    }

    # confirm existence of links generated from custom search replacements
    @cfg['validate_links'] ||= false

    # use notification center to show progress
    @cfg['notifications'] ||= false
    @cfg['pinboard_api_key'] ||= false

    @line_num = nil
    @match_column = nil
    @match_length = nil
  end

  def available_searches
    searches = [
      %w[a Amazon],
      %w[g Google],
      %w[ddg DuckDuckGo],
      %w[yt YouTube],
      ['z', 'DDG Zero-Click Search'],
      %w[wiki Wikipedia],
      ['s', 'Software search (Google)'],
      ['@t', 'Twitter user link'],
      ['@f', 'Facebook user link'],
      ['@l', 'LinkedIn user link'],
      ['@i', 'Instagram user link'],
      ['@m', 'Mastodon user link'],
      ['am', 'Apple Music'],
      ['amart', 'Apple Music Artist'],
      ['amalb', 'Apple Music Album'],
      ['amsong', 'Apple Music Song'],
      ['ampod', 'Apple Music Podcast'],
      ['ipod', 'iTunes podcast'],
      ['isong', 'iTunes song'],
      ['iart', 'iTunes artist'],
      ['ialb', 'iTunes album'],
      ['lsong', 'Last.fm song'],
      ['lart', 'Last.fm artist'],
      ['mas', 'Mac App Store'],
      ['masd', 'Mac App Store developer link'],
      ['itu', 'iTunes App Store'],
      ['itud', 'iTunes App Store developer link'],
      ['imov', 'iTunes Movies'],
      ['def', 'Dictionary definition'],
      %w[hook Hookmarks],
      ['tmdb', 'The Movie Database search'],
      ['tmdba', 'The Movie Database Actor search'],
      ['tmdbm', 'The Movie Database Movie search'],
      ['tmdbt', 'The Movie Database TV search'],
      %w[sp Spelling],
      %w[pb Pinboard],
      ["h", "Web history"],
      ["hs[hb]", "Safari [history, bookmarks]"],
      ["hc[hb]", "Chrome [history, bookmarks]"],
      ["hf[hb]", "Firefox [history, bookmarks]"],
      ["he[hb]", "Edge [history, bookmarks]"],
      ["hb[hb]", "Brave [history, bookmarks]"]
    ]
    out = ''
    searches.each { |s| out += "!#{s[0]}#{spacer(s[0])}#{s[1]}\n" }
    out
  end

  def spacer(str)
    len = str.length
    str.scan(/[mwv]/).each { len += 1 }
    str.scan(/t/).each { len -= 1 }
    case len
    when 0..3
      "\t\t"
    when 4..12
      " \t"
    end
  end

  def help_text
    text = &lt;&lt;~EOHELP
      -- [Available searches] -------------------
      #{available_searches}
    EOHELP

    if @cfg['custom_site_searches']
      text += "\n-- [Custom Searches] ----------------------\n"
      @cfg['custom_site_searches'].each { |label, site| text += "!#{label}#{spacer(label)} #{site}\n" }
    end
    text
  end

  def help_dialog
    text = "[SearchLink v#{VERSION}]\n\n"
    text += help_text
    text += "\nClick \\\"More Help\\\" for additional information"
    text.gsub!(/\n/, '\\\n')
    res = `osascript &lt;&lt;'APPLESCRIPT'
set _res to display dialog "#{text}" buttons {"OK", "More help"} default button "OK" with title "SearchLink Help"

return button returned of _res
APPLESCRIPT
    `.strip
    `open http://brettterpstra.com/projects/searchlink` if res == 'More help'
  end

  def help_cli
    $stdout.puts help_text
  end

  def parse(input)
    @output = ''
    return false if input.empty?

    parse_arguments(input, { only_meta: true })
    @originput = input.dup

    if input.strip =~ /^help$/i
      if SILENT
        help_dialog # %x{open http://brettterpstra.com/projects/searchlink/}
      else
        $stdout.puts "SearchLink v#{VERSION}"
        $stdout.puts 'See http://brettterpstra.com/projects/searchlink/ for help'
      end
      print input
      Process.exit
    end

    @cfg['inline'] = true if input.scan(/\]\(/).length == 1 &amp;&amp; input.split(/\n/).length == 1
    @errors = {}
    @report = []

    links = {}
    @footer = []
    counter_links = 0
    counter_errors = 0

    input.sub!(/\n?&lt;!-- Report:.*?--&gt;\n?/m, '')
    input.sub!(/\n?&lt;!-- Errors:.*?--&gt;\n?/m, '')

    input.scan(/\[(.*?)\]:\s+(.*?)\n/).each { |match| links[match[1].strip] = match[0] }

    prefix = if @cfg['prefix_random']
               if input =~ /\[(\d{4}-)\d+\]: \S+/
                 Regexp.last_match(1)
               else
                 format('%04d-', rand(9999))
               end
             else
               ''
             end

    highest_marker = 0
    input.scan(/^\s{,3}\[(?:#{prefix})?(\d+)\]: /).each do
      m = Regexp.last_match
      highest_marker = m[1].to_i if m[1].to_i &gt; highest_marker
    end

    footnote_counter = 0
    input.scan(/^\s{,3}\[\^(?:#{prefix})?fn(\d+)\]: /).each do
      m = Regexp.last_match
      footnote_counter = m[1].to_i if m[1].to_i &gt; footnote_counter
    end

    if input =~ /\[(.*?)\]\((.*?)\)/
      lines = input.split(/\n/)
      out = []

      total_links = input.scan(/\[(.*?)\]\((.*?)\)/).length
      in_code_block = false
      line_difference = 0
      lines.each_with_index do |line, num|
        @line_num = num - line_difference
        cursor_difference = 0
        # ignore links in code blocks
        if line =~ /^( {4,}|\t+)[^*+\-]/
          out.push(line)
          next
        end
        if line =~ /^[~`]{3,}/
          if in_code_block
            in_code_block = false
            out.push(line)
            next
          else
            in_code_block = true
          end
        end
        if in_code_block
          out.push(line)
          next
        end

        delete_line = false

        search_count = 0

        line.gsub!(/\[(.*?)\]\((.*?)\)/) do |match|
          this_match = Regexp.last_match
          @match_column = this_match.begin(0) - cursor_difference
          match_string = this_match.to_s
          @match_length = match_string.length
          match_before = this_match.pre_match

          invalid_search = false
          ref_title = false

          if match_before.scan(/(^|[^\\])`/).length.odd?
            add_report("Match '#{match_string}' within an inline code block")
            invalid_search = true
          end

          counter_links += 1
          unless SILENT
            $stderr.print("\033[0K\rProcessed: #{counter_links} of #{total_links}, #{counter_errors} errors. ")
          end

          link_text = this_match[1] || ''
          link_info = parse_arguments(this_match[2].strip).strip || ''

          if link_text.strip == '' &amp;&amp; link_info =~ /".*?"/
            link_info.gsub!(/"(.*?)"/) do
              m = Regexp.last_match(1)
              link_text = m if link_text == ''
              m
            end
          end

          if link_info.strip =~ /:$/ &amp;&amp; line.strip == match
            ref_title = true
            link_info.sub!(/\s*:\s*$/, '')
          end

          unless !link_text.empty? || !link_info.sub(/^[!\^]\S+/, '').strip.empty?
            add_error('No input', match)
            counter_errors += 1
            invalid_search = true
          end

          if link_info =~ /^!(\S+)/
            search_type = Regexp.last_match(1)
            unless valid_search?(search_type) || search_type =~ /^(\S+\.)+\S+$/
              add_error("Invalid search#{did_you_mean(search_type)}", match)
              invalid_search = true
            end
          end

          if invalid_search
            match
          elsif link_info =~ /^\^(.+)/
            m = Regexp.last_match
            if m[1].nil? || m[1] == ''
              match
            else
              note = m[1].strip
              footnote_counter += 1
              ref = if !link_text.empty? &amp;&amp; link_text.scan(/\s/).empty?
                      link_text
                    else
                      format('%&lt;p&gt;sfn%&lt;c&gt;04d', p: prefix, c: footnote_counter)
                    end
              add_footer "[^#{ref}]: #{note}"
              res = "[^#{ref}]"
              cursor_difference += (@match_length - res.length)
              @match_length = res.length
              add_report("#{match_string} =&gt; Footnote #{ref}")
              res
            end
          elsif (link_text == '' &amp;&amp; link_info == '') || url?(link_info)
            add_error("Invalid search", match) unless url?(link_info)
            match
          else
            link_info = link_text if !link_text.empty? &amp;&amp; link_info == ''

            search_type = ''
            search_terms = ''
            link_only = false
            @clipboard = false
            @titleize = @cfg['empty_uses_page_title']

            if link_info =~ /^(?:[!\^](\S+))\s*(.*)$/
              m = Regexp.last_match

              search_type = m[1].nil? ? 'g' : m[1]

              search_terms = m[2].gsub(/(^["']|["']$)/, '')
              search_terms.strip!

              # if the link text is just '%' replace with title regardless of config settings
              if link_text == '%' &amp;&amp; search_terms &amp;&amp; !search_terms.empty?
                @titleize = true
                link_text = ''
              end

              search_terms = link_text if search_terms == ''

              # if the input starts with a +, append it to the link text as the search terms
              search_terms = "#{link_text} #{search_terms.strip.sub(/^\+\s*/, '')}" if search_terms.strip =~ /^\+[^+]/

              # if the end of input contain "^", copy to clipboard instead of STDOUT
              @clipboard = true if search_terms =~ /(!!)?\^(!!)?$/

              # if the end of input contains "!!", only print the url
              link_only = true if search_terms =~ /!!\^?$/

              search_terms.sub!(/(!!)?\^?(!!)?$/,"")

            elsif link_info =~ /^!/
              search_word = link_info.match(/^!(\S+)/)

              if search_word &amp;&amp; valid_search?(search_word[1])
                search_type = search_word[1] unless search_word.nil?
                search_terms = link_text
              elsif search_word &amp;&amp; search_word[1] =~ /^(\S+\.)+\S+$/
                search_type = 'g'
                search_terms = "site:#{search_word[1]} #{link_text}"
              else
                add_error("Invalid search#{did_you_mean(search_word[1])}", match)
                search_type = false
                search_terms = false
              end

            elsif link_text &amp;&amp; !link_text.empty? &amp;&amp; (link_info.nil? || link_info.empty?)
              search_type = 'g'
              search_terms = link_text
            elsif link_info &amp;&amp; !link_info.empty?
              search_type = 'g'
              search_terms = link_info
            else
              add_error('Invalid search', match)
              search_type = false
              search_terms = false
            end

            if search_type &amp;&amp; !search_terms.empty?
              @cfg['custom_site_searches'].each do |k, v|
                next unless search_type == k

                link_text = search_terms if !@titleize &amp;&amp; link_text == ''
                v = parse_arguments(v, { no_restore: true })
                if v =~ %r{^(/|http)}i
                  search_type = 'r'
                  tokens = v.scan(/\$term\d+[ds]?/).sort.uniq

                  if !tokens.empty?
                    highest_token = 0
                    tokens.each do |token|
                      if token =~ /(\d+)[ds]?$/ &amp;&amp; Regexp.last_match(1).to_i &gt; highest_token
                        highest_token = Regexp.last_match(1).to_i
                      end
                    end
                    terms_p = search_terms.split(/ +/)
                    if terms_p.length &gt; highest_token
                      remainder = terms_p[highest_token - 1..-1].join(' ')
                      terms_p = terms_p[0..highest_token - 2]
                      terms_p.push(remainder)
                    end
                    tokens.each do |t|
                      next unless t =~ /(\d+)[ds]?$/

                      int = Regexp.last_match(1).to_i - 1
                      replacement = terms_p[int]
                      case t
                      when /d$/
                        replacement.downcase!
                        re_down = ''
                      when /s$/
                        replacement.slugify!
                        re_down = ''
                      else
                        re_down = '(?!d|s)'
                      end
                      v.gsub!(/#{Regexp.escape(t) + re_down}/, ERB::Util.url_encode(replacement))
                    end
                    search_terms = v
                  else
                    search_terms = v.gsub(/\$term[ds]?/i) do |mtch|
                      search_terms.downcase! if mtch =~ /d$/i
                      search_terms.slugify! if mtch =~ /s$/i
                      ERB::Util.url_encode(search_terms)
                    end
                  end
                else
                  search_type = 'g'
                  search_terms = "site:#{v} #{search_terms}"
                end

                break
              end
            end

            if search_type &amp;&amp; search_terms
              # warn "Searching #{search_type} for #{search_terms}"
              search_count += 1
              url, title, link_text = do_search(search_type, search_terms, link_text, search_count)

              if url
                title = titleize(url) if @titleize &amp;&amp; title == ''

                link_text = title if link_text == '' &amp;&amp; title
                force_title = search_type =~ /def/ ? true : false

                if link_only || search_type =~ /sp(ell)?/ || url == 'embed'
                  url = title if url == 'embed'
                  cursor_difference += @match_length - url.length
                  @match_length = url.length
                  add_report("#{match_string} =&gt; #{url}")
                  url
                elsif ref_title
                  unless links.key? url
                    links[url] = link_text
                    add_footer make_link('ref_title', link_text, url, title: title, force_title: force_title)
                  end
                  delete_line = true
                elsif @cfg['inline']
                  res = make_link('inline', link_text, url, title: title, force_title: force_title)
                  cursor_difference += @match_length - res.length
                  @match_length = res.length
                  add_report("#{match_string} =&gt; #{url}")
                  res
                else
                  unless links.key? url
                    highest_marker += 1
                    links[url] = format('%&lt;pre&gt;s%&lt;m&gt;04d', pre: prefix, m: highest_marker)
                    add_footer make_link('ref_title', links[url], url, title: title, force_title: force_title)
                  end

                  type = @cfg['inline'] ? 'inline' : 'ref_link'
                  res = make_link(type, link_text, links[url], title: false, force_title: force_title)
                  cursor_difference += @match_length - res.length
                  @match_length = res.length
                  add_report("#{match_string} =&gt; #{url}")
                  res
                end
              else
                add_error('No results', "#{search_terms} (#{match_string})")
                counter_errors += 1
                match
              end
            else
              add_error('Invalid search', match)
              counter_errors += 1
              match
            end
          end
        end
        line_difference += 1 if delete_line
        out.push(line) unless delete_line
        delete_line = false
      end
      warn "\n" unless SILENT

      input = out.delete_if { |l| l.strip =~ /^&lt;!--DELETE--&gt;$/ }.join("\n")

      if @cfg['inline']
        add_output "#{input}\n"
        add_output "\n#{print_footer}" unless @footer.empty?
      elsif @footer.empty?
        add_output input
      else
        last_line = input.strip.split(/\n/)[-1]
        case last_line
        when /^\[.*?\]: http/
          add_output "#{input.rstrip}\n"
        when /^\[\^.*?\]: /
          add_output input.rstrip
        else
          add_output "#{input}\n\n"
        end
        add_output "#{print_footer}\n\n"
      end
      @line_num = nil
      add_report("Processed: #{total_links} links, #{counter_errors} errors.")
      print_report
      print_errors
    else
      link_only = false
      @clipboard = false

      res = parse_arguments(input.strip!).strip
      input = res.nil? ? input : res

      # if the end of input contain "^", copy to clipboard instead of STDOUT
      @clipboard = true if input =~ /\^[!~:]*$/

      # if the end of input contains "!!", only print the url
      link_only = true if input =~ /!![\^~:]*$/

      reference_link = input =~ /:([!\^\s~]*)$/

      # if end of input contains ~, pull url from clipboard
      if input =~ /~[:\^!\s]*$/
        input.sub!(/[:!\^\s~]*$/, '')
        clipboard = `__CF_USER_TEXT_ENCODING=$UID:0x8000100:0x8000100 pbpaste`.strip
        if url?(clipboard)
          type = reference_link ? 'ref_title' : 'inline'
          print make_link(type, input.strip, clipboard)
        else
          print @originput
        end
        Process.exit
      end

      input.sub!(/[:!\^\s~]*$/, '')

      ## Maybe if input is just a URL, convert it to a link
      ## using hostname as text without doing search
      if only_url?(input.strip)
        type = reference_link ? 'ref_title' : 'inline'
        url, title = url_to_link(input.strip, type)
        print make_link(type, title, url, title: false, force_title: false)
        Process.exit
      end

      # check for additional search terms in parenthesis
      additional_terms = ''
      if input =~ /\((.*?)\)/
        additional_terms = " #{Regexp.last_match(1).strip}"
        input.sub!(/\(.*?\)/, '')
      end

      # Maybe detect "search + addition terms" and remove additional terms from link text?
      # if input =~ /\+(.+?)$/
      #   additional_terms = "#{additional_terms} #{Regexp.last_match(1).strip}"
      #   input.sub!(/\+.*?$/, '').strip!
      # end

      link_text = false

      if input =~ /"(.*?)"/
        link_text = Regexp.last_match(1)
        input.gsub!(/"(.*?)"/, '\1')
      end

      # remove quotes from terms, just in case
      # input.sub!(/^(!\S+)?\s*(["'])(.*?)\2([\!\^]+)?$/, "\\1 \\3\\4")

      case input
      when /^!(\S+)\s+(.*)$/
        type = Regexp.last_match(1)
        link_info = Regexp.last_match(2).strip
        link_text ||= link_info
        terms = link_info + additional_terms
        terms.strip!

        if valid_search?(type) || type =~ /^(\S+\.)+\S+$/
          if type &amp;&amp; terms &amp;&amp; !terms.empty?
            @cfg['custom_site_searches'].each do |k, v|
              next unless type == k

              link_text = terms if link_text == ''
              v = parse_arguments(v, { no_restore: true })
              if v =~ %r{^(/|http)}i
                type = 'r'
                tokens = v.scan(/\$term\d+[ds]?/).sort.uniq

                if !tokens.empty?
                  highest_token = 0
                  tokens.each do |token|
                    t = Regexp.last_match(1)
                    highest_token = t.to_i if token =~ /(\d+)d?$/ &amp;&amp; t.to_i &gt; highest_token
                  end
                  terms_p = terms.split(/ +/)
                  if terms_p.length &gt; highest_token
                    remainder = terms_p[highest_token - 1..-1].join(' ')
                    terms_p = terms_p[0..highest_token - 2]
                    terms_p.push(remainder)
                  end
                  tokens.each do |t|
                    next unless t =~ /(\d+)d?$/

                    int = Regexp.last_match(1).to_i - 1
                    replacement = terms_p[int]
                    case t
                    when /d$/
                      replacement.downcase!
                      re_down = ''
                    when /s$/
                      replacement.slugify!
                      re_down = ''
                    else
                      re_down = '(?!d|s)'
                    end
                    v.gsub!(/#{Regexp.escape(t) + re_down}/, ERB::Util.url_encode(replacement))
                  end
                  terms = v
                else
                  terms = v.gsub(/\$term[ds]?/i) do |mtch|
                    terms.downcase! if mtch =~ /d$/i
                    terms.slugify! if mtch =~ /s$/i
                    ERB::Util.url_encode(terms)
                  end
                end
              else
                type = 'g'
                terms = "site:#{v} #{terms}"
              end

              break
            end
          end

          if type =~ /^(\S+\.)+\S+$/
            terms = "site:#{type} #{terms}"
            type = 'g'
          end
          search_count ||= 0
          search_count += 1
          url, title, link_text = do_search(type, terms, link_text, search_count)
        else
          add_error("Invalid search#{did_you_mean(type)}", input)
          counter_errors += 1
        end
      when /^([tfilm])?@(\S+)\s*$/
        type = Regexp.last_match(1)
        unless type
          if Regexp.last_match(2) =~ /[a-z0-9_]@[a-z0-9_.]+/i
            type = 'm'
          else
            type = 't'
          end
        end
        link_text = input.sub(/^[tfilm]/, '')
        url, title = social_handle(type, link_text)
        link_text = title
      else
        link_text ||= input
        url, title = ddg(input)
      end

      if url
        if type =~ /sp(ell)?/
          add_output(url)
        elsif link_only
          add_output(url)
        elsif url == 'embed'
          add_output(title)
        else
          type = reference_link ? 'ref_title' : 'inline'
          add_output make_link(type, link_text, url, title: title, force_title: false)
          print_errors
        end
      else
        add_error('No results', title)
        add_output @originput.chomp
        print_errors
      end

      if @clipboard
        if @output == @originput
          warn "No results found"
        else
          `echo #{Shellwords.escape(@output)}|tr -d "\n"|pbcopy`
          warn "Results in clipboard"
        end
      end
    end
  end

  private

  def parse_arguments(string, opt={})
    input = string.dup
    return "" if input.nil?

    skip_flags = opt[:only_meta] || false
    no_restore = opt[:no_restore] || false
    restore_prev_config unless no_restore

    unless skip_flags
      input.gsub!(/(\+\+|--)([dirtv]+)\b/) do
        m = Regexp.last_match
        bool = m[1] == '++' ? '' : 'no-'
        output = ' '
        m[2].split('').each do |arg|
          output += case arg
                    when 'd'
                      "--#{bool}debug "
                    when 'i'
                      "--#{bool}inline "
                    when 'r'
                      "--#{bool}prefix_random "
                    when 't'
                      "--#{bool}include_titles "
                    when 'v'
                      "--#{bool}validate_links "
                    else
                      ''
                    end
        end
        output
      end
    end

    options = %w[debug country_code inline prefix_random include_titles validate_links]
    options.each do |o|
      if input =~ /^#{o}:\s+(.*?)$/
        val = Regexp.last_match(1).strip
        val = true if val =~ /true/i
        val = false if val =~ /false/i
        @cfg[o] = val
        $stderr.print "\r\033[0KGlobal config: #{o} = #{@cfg[o]}\n" unless SILENT
      end

      next if skip_flags

      while input =~ /^#{o}:\s+(.*?)$/ || input =~ /--(no-)?#{o}/
        next unless input =~ /--(no-)?#{o}/ &amp;&amp; !skip_flags

        unless @prev_config.key? o
          @prev_config[o] = @cfg[o]
          bool = Regexp.last_match(1).nil? || Regexp.last_match(1) == '' ? true : false
          @cfg[o] = bool
          $stderr.print "\r\033[0KLine config: #{o} = #{@cfg[o]}\n" unless SILENT
        end
        input.sub!(/\s?--(no-)?#{o}/, '')
      end
    end
    @clipboard ? string : input
  end

  def restore_prev_config
    @prev_config&amp;.each do |k, v|
      @cfg[k] = v
      $stderr.print "\r\033[0KReset config: #{k} = #{@cfg[k]}\n" unless SILENT
    end
    @prev_config = {}
  end

  def make_link(type, text, url, title: false, force_title: false)
    text = title || titleize(url) if @titleize &amp;&amp; text == ''

    title = title &amp;&amp; (@cfg['include_titles'] || force_title) ? %( "#{title.clean}") : ''

    case type
    when 'ref_title'
      %(\n[#{text.strip}]: #{url}#{title})
    when 'ref_link'
      %([#{text.strip}][#{url}])
    when 'inline'
      %([#{text.strip}](#{url}#{title}))
    end
  end

  def add_output(str)
    print str if @printout &amp;&amp; !@clipboard
    @output += str
  end

  def add_footer(str)
    @footer ||= []
    @footer.push(str.strip)
  end

  def print_footer
    unless @footer.empty?

      footnotes = []
      @footer.delete_if do |note|
        note.strip!
        case note
        when /^\[\^.+?\]/
          footnotes.push(note)
          true
        when /^\s*$/
          true
        else
          false
        end
      end

      output = @footer.sort.join("\n").strip
      output += "\n\n" if !output.empty? &amp;&amp; !footnotes.empty?
      output += footnotes.join("\n\n") unless footnotes.empty?
      return output.gsub(/\n{3,}/, "\n\n")
    end

    ''
  end

  def add_report(str)
    return unless @cfg['report']

    unless @line_num.nil?
      position = "#{@line_num}:"
      position += @match_column.nil? ? '0:' : "#{@match_column}:"
      position += @match_length.nil? ? '0' : @match_length.to_s
    end
    @report.push("(#{position}): #{str}")
    warn "(#{position}): #{str}" unless SILENT
  end

  def add_error(type, str)
    return unless @cfg['debug']

    unless @line_num.nil?
      position = "#{@line_num}:"
      position += @match_column.nil? ? '0:' : "#{@match_column}:"
      position += @match_length.nil? ? '0' : @match_length.to_s
    end
    @errors[type] ||= []
    @errors[type].push("(#{position}): #{str}")
  end

  def print_report
    return if (@cfg['inline'] &amp;&amp; @originput.split(/\n/).length == 1) || @clipboard

    return if @report.empty?

    out = "\n&lt;!-- Report:\n#{@report.join("\n")}\n--&gt;\n"
    add_output out
  end

  def print_errors(type = 'Errors')
    return if @errors.empty?

    out = ''
    inline = if @originput.split(/\n/).length &gt; 1
               false
             else
               @cfg['inline'] || @originput.split(/\n/).length == 1
             end

    @errors.each do |k, v|
      next if v.empty?

      v.each_with_index do |err, i|
        out += "(#{k}) #{err}"
        out += if inline
                 i == v.length - 1 ? ' | ' : ', '
               else
                 "\n"
               end
      end
    end

    unless out == ''
      sep = inline ? ' ' : "\n"
      out.sub!(/\| /, '')
      out = "#{sep}&lt;!-- #{type}:#{sep}#{out}--&gt;#{sep}"
    end
    if @clipboard
      warn out
    else
      add_output out
    end
  end

  def print_or_copy(text)
    # Process.exit unless text
    if @clipboard
      `echo #{Shellwords.escape(text)}|tr -d "\n"|pbcopy`
      print @originput
    else
      print text
    end
  end

  def notify(str, sub)
    return unless @cfg['notifications']

    `osascript -e 'display notification "SearchLink" with title "#{str}" subtitle "#{sub}"'`
  end

  def valid_link?(uri_str, limit = 5)
    notify('Validating', uri_str)
    return false if limit.zero?

    url = URI(uri_str)
    return true unless url.scheme

    url.path = '/' if url.path == ''
    # response = Net::HTTP.get_response(URI(uri_str))
    response = false

    Net::HTTP.start(url.host, url.port, use_ssl: url.scheme == 'https') do |http|
      response = http.request_head(url.path)
    end

    case response
    when Net::HTTPMethodNotAllowed, Net::HTTPServiceUnavailable
      unless /amazon\.com/ =~ url.host
        add_error('link validation', "Validation blocked: #{uri_str} (#{e})")
      end
      notify('Error validating', uri_str)
      true
    when Net::HTTPSuccess
      true
    when Net::HTTPRedirection
      location = response['location']
      valid_link?(location, limit - 1)
    else
      notify('Error validating', uri_str)
      false
    end
  rescue StandardError =&gt; e
    notify('Error validating', uri_str)
    add_error('link validation', "Possibly invalid =&gt; #{uri_str} (#{e})")
    true
  end

  def url?(input)
    input =~ %r{^(#.*|https?://\S+|/\S+|\S+/|[^!]\S+\.\S+)(\s+".*?")?$}
  end

  def only_url?(input)
    input =~ %r{(?i)^((http|https)://)?([\w\-_]+(\.[\w\-_]+)+)([\w\-.,@?^=%&amp;amp;:/~+#]*[\w\-@^=%&amp;amp;/~+#])?$}
  end

  def ref_title_for_url(url)
    url = URI.parse(url) if url.is_a?(String)

    parts = url.hostname.split(/\./)
    domain = if parts.count &gt; 1
               parts.slice(-2, 1).join('.')
             else
               parts.join('.')
             end

    path = url.path.split(%r{/}).last

    path.length &gt; domain.length ? path : domain
  end

  def url_to_link(input, type)
    if only_url?(input)
      input.sub!(%r{(?mi)^(?!https?://)(.*?)$}, 'https://\1')
      url = URI.parse(input.downcase)

      title = if type == 'ref_title'
                ref_title_for_url(url)
              else
                titleize(url.to_s) || input.sub(%r{^https?://}, '')
              end

      return [url.to_s, title] if url.hostname
    end
    false
  end

  def best_search_match(term)
    searches = all_possible_searches.dup
    searches.select do |s|
      s.matches_score(term, separator: '', start_word: false) &gt; 8
    end
  end

  def did_you_mean(term)
    matches = best_search_match(term)
    matches.empty? ? '' : ", did you mean #{matches.map { |m| "!#{m}" }.join(', ')}?"
  end

  def all_possible_searches
    %w[
      h
      hsh
      hshb
      hsb
      hch
      hcb
      hchb
      hfh
      hfb
      hfhb
      heh
      heb
      hehb
      hbh
      hbb
      hbhb
      a
      imov
      g
      ddg
      z
      zero
      b
      wiki
      def
      mas
      masd
      itu
      itud
      tmdb
      tmdba
      tmdbm
      tmdbt
      s
      iart
      ialb
      isong
      ipod
      iarte
      ialbe
      isonge
      ipode
      lart
      lalb
      lsong
      lpod
      larte
      lalbe
      lsonge
      lpode
      amart
      amalb
      amsong
      ampod
      amarte
      amalbe
      amsonge
      ampode
      @t
      @f
      @i
      @l
      @m
      r
      sp
      spell
      pb
      yt
    ].concat(@cfg['custom_site_searches'].keys)
  end

  def valid_searches
    [
      'h(([scfbe])([hb])?)*',
      'a',
      'imov',
      'g',
      'ddg',
      'z(ero)?',
      'b',
      'wiki',
      'def',
      'masd?',
      'itud?',
      'tmdb[amt]?',
      's',
      '(i|am|l)(art|alb|song|pod)e?',
      '@[tfilm]',
      'r',
      'sp(ell)?',
      'pb',
      'yt'
    ]
  end

  def valid_search?(term)
    valid = false
    valid = true if term =~ /^(#{valid_searches.join('|')})$/
    valid = true if @cfg['custom_site_searches'].keys.include? term
    notify("Invalid search#{did_you_mean(term)}", term) unless valid
    valid
  end

  def search_brave_history(term)
    # Google history
    history_file = File.expand_path('~/Library/Application Support/BraveSoftware/Brave-Browser/Default/History')
    if File.exist?(history_file)
      notify('Searching Brave History', term)
      search_chromium_history(history_file, term)
    else
      false
    end
  end

  def search_edge_history(term)
    # Google history
    history_file = File.expand_path('~/Library/Application Support/Microsoft/Edge/Default/History')
    if File.exist?(history_file)
      notify('Searching Edge History', term)
      search_chromium_history(history_file, term)
    else
      false
    end
  end

  def search_chrome_history(term)
    # Google history
    history_file = File.expand_path('~/Library/Application Support/Google/Chrome/Default/History')
    if File.exist?(history_file)
      notify('Searching Chrome History', term)
      search_chromium_history(history_file, term)
    else
      false
    end
  end

  def search_chromium_history(history_file, term)
    tmpfile = "#{history_file}.tmp"
    FileUtils.cp(history_file, tmpfile)

    terms = []
    terms.push("(url NOT LIKE '%search/?%'
               AND url NOT LIKE '%?q=%'
               AND url NOT LIKE '%?s=%'
               AND url NOT LIKE '%duckduckgo.com/?t%')")
    terms.concat(term.split(/\s+/).map do |t|
      "(url LIKE '%#{t.strip.downcase}%'
      OR title LIKE '%#{t.strip.downcase}%')"
    end)
    query = terms.join(' AND ')
    most_recent = `sqlite3 -json '#{tmpfile}' "select title, url,
    datetime(last_visit_time / 1000000 + (strftime('%s', '1601-01-01')), 'unixepoch') as datum
    from urls where #{query} order by datum desc limit 1 COLLATE NOCASE;"`.strip
    FileUtils.rm_f(tmpfile)
    return false if most_recent.strip.empty?

    bm = JSON.parse(most_recent)[0]

    date = Time.parse(bm['datum'])
    [bm['url'], bm['title'], date]
  end

  def search_brave_bookmarks(term)
    bookmarks_file = File.expand_path('~/Library/Application Support/BraveSoftware/Brave-Browser/Default/Bookmarks')

    if File.exist?(bookmarks_file)
      notify('Searching Brave Bookmarks', term)
      return search_chromiumn_bookmarks(bookmarks_file, term)
    end

    false
  end

  def search_edge_bookmarks(term)
    bookmarks_file = File.expand_path('~/Library/Application Support/Microsoft/Edge/Default/Bookmarks')

    if File.exist?(bookmarks_file)
      notify('Searching Brave Bookmarks', term)
      return search_chromiumn_bookmarks(bookmarks_file, term)
    end

    false
  end

  def search_chrome_bookmarks(term)
    bookmarks_file = File.expand_path('~/Library/Application Support/Google/Chrome/Default/Bookmarks')

    if File.exist?(bookmarks_file)
      notify('Searching Chrome Bookmarks', term)
      return search_chromium_bookmarks(bookmarks_file, term)
    end

    false
  end

  def search_chromium_bookmarks(bookmarks_file, term)
    chrome_bookmarks = JSON.parse(IO.read(bookmarks_file))

    if chrome_bookmarks
      terms = term.split(/\s+/)
      roots = chrome_bookmarks['roots']
      urls = extract_chrome_bookmarks(roots)
      urls.sort_by! { |bookmark| bookmark['date_added'] }
      urls.select do |u|
        found = true
        terms.each { |t| found = false unless u['url'] =~ /#{t}/i || u['title'] =~ /#{t}/i }
        found
      end
      unless urls.empty?
        lastest_bookmark = urls[-1]
        return [lastest_bookmark['url'], lastest_bookmark['title'], lastest_bookmark['date']]
      end
    end

    false
  end

  def search_firefox_history(term)
    # Firefox history
    base = File.expand_path('~/Library/Application Support/Firefox/Profiles')
    Dir.chdir(base)
    profile = Dir.glob('*default-release')
    return false unless profile

    src = File.join(base, profile[0], 'places.sqlite')

    if File.exist?(src)
      notify('Searching Firefox History', term)
      tmpfile = "#{src}.tmp"
      FileUtils.cp(src, tmpfile)

      terms = []
      terms.push("(moz_places.url NOT LIKE '%search/?%'
                 AND moz_places.url NOT LIKE '%?q=%'
                 AND moz_places.url NOT LIKE '%?s=%'
                 AND moz_places.url NOT LIKE '%duckduckgo.com/?t%')")
      terms.concat(term.split(/\s+/).map do |t|
        "(moz_places.url LIKE '%#{t.strip.downcase}%' OR moz_places.title LIKE '%#{t.strip.downcase}%')"
      end)
      query = terms.join(' AND ')
      most_recent = `sqlite3 -json '#{tmpfile}' "select moz_places.title, moz_places.url,
      datetime(moz_historyvisits.visit_date/1000000, 'unixepoch', 'localtime') as datum
      from moz_places, moz_historyvisits where moz_places.id = moz_historyvisits.place_id
      and #{query} order by datum desc limit 1 COLLATE NOCASE;"`.strip
      FileUtils.rm_f(tmpfile)

      return false if most_recent.strip.empty?

      bm = JSON.parse(most_recent)[0]

      date = Time.parse(bm['datum'])
      [bm['url'], bm['title'], date]
    else
      false
    end
  end

  def search_firefox_bookmarks(term)
    # Firefox history
    base = File.expand_path('~/Library/Application Support/Firefox/Profiles')
    Dir.chdir(base)
    profile = Dir.glob('*default-release')
    return false unless profile

    src = File.join(base, profile[0], 'places.sqlite')

    if File.exist?(src)
      notify('Searching Firefox Bookmarks', term)
      tmpfile = "#{src}.tmp"
      FileUtils.cp(src, tmpfile)

      terms = []
      terms.push("(h.url NOT LIKE '%search/?%'
                 AND h.url NOT LIKE '%?q=%'
                 AND h.url NOT LIKE '%?s=%'
                 AND h.url NOT LIKE '%duckduckgo.com/?t%')")
      terms.concat(term.split(/\s+/).map do |t|
        "(h.url LIKE '%#{t.strip.downcase}%' OR b.title LIKE '%#{t.strip.downcase}%')"
      end)

      query = terms.join(' AND ')

      most_recent = `sqlite3 -json '#{tmpfile}' "select h.url, b.title,
      datetime(b.dateAdded/1000000, 'unixepoch', 'localtime') as datum
      FROM moz_places h JOIN moz_bookmarks b ON h.id = b.fk
      where #{query} order by datum desc limit 1 COLLATE NOCASE;"`.strip
      FileUtils.rm_f(tmpfile)

      return false if most_recent.strip.empty?

      bm = JSON.parse(most_recent)[0]

      date = Time.parse(bm['datum'])
      [bm['url'], bm['title'], date]
    else
      false
    end
  end

  def search_safari_history(term)
    # Firefox history
    src = File.expand_path('~/Library/Safari/History.db')
    if File.exist?(src)
      notify('Searching Safari History', term)
      tmpfile = "#{src}.tmp"
      FileUtils.cp(src, tmpfile)

      terms = []
      terms.push("(url NOT LIKE '%search/?%'
                 AND url NOT LIKE '%?q=%' AND url NOT LIKE '%?s=%'
                 AND url NOT LIKE '%duckduckgo.com/?t%')")
      terms.concat(term.split(/\s+/).map do |t|
        "(url LIKE '%#{t.strip.downcase}%' OR title LIKE '%#{t.strip.downcase}%')"
      end)
      query = terms.join(' AND ')
      most_recent = `sqlite3 -json '#{tmpfile}' "select title, url,
      datetime(visit_time/1000000, 'unixepoch', 'localtime') as datum
      from history_visits INNER JOIN history_items ON history_items.id = history_visits.history_item
      where #{query} order by datum desc limit 1 COLLATE NOCASE;"`.strip
      FileUtils.rm_f(tmpfile)

      return false if most_recent.strip.empty?

      bm = JSON.parse(most_recent)[0]
      date = Time.parse(bm['datum'])
      [bm['url'], bm['title'], date]
    else
      false
    end
  end

  def search_safari_bookmarks(terms)
    result = nil

    data = `plutil -convert xml1 -o - ~/Library/Safari/Bookmarks.plist`.strip
    parent = Plist::parse_xml(data)
    result = get_safari_bookmarks(parent, terms).first

    return false if result.nil?

    [result[:url], result[:title], Time.now]
  end

  def get_safari_bookmarks(parent, terms)
    results = []
    if parent.is_a?(Array)
      parent.each do |c|
        if c.is_a?(Hash)
          if c.key?('Children')
            results.concat(get_safari_bookmarks(c['Children'], terms))
          elsif c.key?('URIDictionary')
            title = c['URIDictionary']['title']
            url = c['URLString']
            results.push({ url: url, title: title }) if title =~ /#{terms}/i || url =~ /#{terms}/i
          end
        end
      end
    else
      results.concat(get_safari_bookmarks(parent['Children'], terms))
    end
    results.sort_by { |h| h[:title] }.uniq
  end

  def search_history(term,types = [])
    if types.empty?
      return false unless @cfg['history_types']

      types = @cfg['history_types']
    end

    results = []

    if !types.empty?
      types.each do |type|
        url, title, date = case type
                           when 'chrome_history'
                             search_chrome_history(term)
                           when 'chrome_bookmarks'
                             search_chrome_bookmarks(term)
                           when 'safari_bookmarks'
                             search_safari_bookmarks(term)
                           when 'safari_history'
                             search_safari_history(term)
                           when 'firefox_history'
                             search_firefox_history(term)
                           when 'firefox_bookmarks'
                             search_firefox_bookmarks(term)
                           when 'edge_history'
                             search_edge_history(term)
                           when 'edge_bookmarks'
                             search_edge_bookmarks(term)
                           when 'brave_history'
                             search_brave_history(term)
                           when 'brave_bookmarks'
                             search_brave_bookmarks(term)
                           else
                             false
                           end

        results &lt;&lt; { 'url' =&gt; url, 'title' =&gt; title, 'date' =&gt; date } if url
      end

      if results.empty?
        false
      else
        out = results.sort_by! { |r| r['date'] }.last
        [out['url'], out['title']]
      end
    else
      false
    end
  end

  def extract_chrome_bookmarks(json, urls = [])
    if json.instance_of?(Array)
      json.each { |item| urls = extract_chrome_bookmarks(item, urls) }
    elsif json.instance_of?(Hash)
      if json.key? 'children'
        urls = extract_chrome_bookmarks(json['children'], urls)
      elsif json['type'] == 'url'
        date = Time.at(json['date_added'].to_i / 1000000 + (Time.new(1601, 01, 01).strftime('%s').to_i))
        urls &lt;&lt; { 'url' =&gt; json['url'], 'title' =&gt; json['name'], 'date' =&gt; date }
      else
        json.each { |_, v| urls = extract_chrome_bookmarks(v, urls) }
      end
    else
      return urls
    end
    urls
  end

  def tmdb(search_type, terms)
    type = case search_type
           when /t$/
             'tv'
           when /m$/
             'movie'
           when /a$/
             'person'
           else
             'multi'
           end
    body = `/usr/bin/curl -sSL 'https://api.themoviedb.org/3/search/#{type}?query=#{ERB::Util.url_encode(terms)}&amp;api_key=2bd76548656d92517f14d64766e87a02'`
    data = JSON.parse(body)
    if data.key?('results') &amp;&amp; data['results'].count.positive?
      res = data['results'][0]
      type = res['media_type'] if type == 'multi'
      id = res['id']
      url = "https://www.themoviedb.org/#{type}/#{id}"
      title = res['name']
      title ||= res['title']
      title ||= terms
    else
      url, title = ddg("site:imdb.com #{terms}")

      return false unless url
    end

    [url, title]
  end

  def wiki(terms)
    ## Hack to scrape wikipedia result
    body = `/usr/bin/curl -sSL 'https://en.wikipedia.org/wiki/Special:Search?search=#{ERB::Util.url_encode(terms)}&amp;go=Go'`
    return unless body

    body = body.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9

    begin
      title = body.match(/"wgTitle":"(.*?)"/)[1]
      url = body.match(/&lt;link rel="canonical" href="(.*?)"/)[1]
    rescue StandardError
      return false
    end

    [url, title]

    ## Removed because Ruby 2.0 does not like https connection to wikipedia without using gems?
    # uri = URI.parse("https://en.wikipedia.org/w/api.php?action=query&amp;format=json&amp;prop=info&amp;inprop=url&amp;titles=#{CGI.escape(terms)}")
    # req = Net::HTTP::Get.new(uri.path)
    # req['Referer'] = "http://brettterpstra.com"
    # req['User-Agent'] = "SearchLink (http://brettterpstra.com)"

    # res = Net::HTTP.start(uri.host, uri.port,
    #   :use_ssl =&gt; true,
    #   :verify_mode =&gt; OpenSSL::SSL::VERIFY_NONE) do |https|
    #     https.request(req)
    #   end

    # if RUBY_VERSION.to_f &gt; 1.9
    #   body = res.body.force_encoding('utf-8')
    # else
    #   body = res.body
    # end

    # result = JSON.parse(body)

    # if result
    #   result['query']['pages'].each do |page,info|
    #     unless info.key? "missing"
    #       return [info['fullurl'],info['title']]
    #     end
    #   end
    # end
    # return false
  end

  def zero_click(terms)
    url = URI.parse("http://api.duckduckgo.com/?q=#{ERB::Util.url_encode(terms)}&amp;format=json&amp;no_redirect=1&amp;no_html=1&amp;skip_disambig=1")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9

    result = JSON.parse(res)
    return ddg(terms) unless result

    wiki_link = result['AbstractURL'] || result['Redirect']
    title = result['Heading'] || false

    if !wiki_link.empty? &amp;&amp; !title.empty?
      [wiki_link, title]
    else
      ddg(terms)
    end
  end

  # Search apple music
  # terms =&gt; search terms (unescaped)
  # media =&gt; music, podcast
  # entity =&gt; optional: artist, song, album, podcast
  # returns {:type=&gt;,:id=&gt;,:url=&gt;,:title}
  def applemusic(terms, media = 'music', entity = '')
    aff = @cfg['itunes_affiliate']
    output = {}

    url = URI.parse("http://itunes.apple.com/search?term=#{ERB::Util.url_encode(terms)}&amp;country=#{@cfg['country_code']}&amp;media=#{media}&amp;entity=#{entity}")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9
    res.gsub!(/(?mi)[\x00-\x08\x0B-\x0C\x0E-\x1F]/, '')
    json = JSON.parse(res)
    return false unless json['resultCount']&amp;.positive?

    result = json['results'][0]

    case result['wrapperType']
    when 'track'
      if result['kind'] == 'podcast'
        output[:type] = 'podcast'
        output[:id] = result['collectionId']
        output[:url] = result['collectionViewUrl'].to_am + aff
        output[:title] = result['collectionName']
      else
        output[:type] = 'song'
        output[:album] = result['collectionId']
        output[:id] = result['trackId']
        output[:url] = result['trackViewUrl'].to_am + aff
        output[:title] = "#{result['trackName']} by #{result['artistName']}"
      end
    when 'collection'
      output[:type] = 'album'
      output[:id] = result['collectionId']
      output[:url] = result['collectionViewUrl'].to_am + aff
      output[:title] = "#{result['collectionName']} by #{result['artistName']}"
    when 'artist'
      output[:type] = 'artist'
      output[:id] = result['artistId']
      output[:url] = result['artistLinkUrl'].to_am + aff
      output[:title] = result['artistName']
    end
    return false if output.empty?

    output
  end

  def itunes(entity, terms, dev, aff = nil)
    aff ||= @cfg['itunes_affiliate']

    url = URI.parse("http://itunes.apple.com/search?term=#{ERB::Util.url_encode(terms)}&amp;country=#{@cfg['country_code']}&amp;entity=#{entity}")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8').encode # if RUBY_VERSION.to_f &gt; 1.9

    begin
      json = JSON.parse(res)
    rescue StandardError =&gt; e
      add_error('Invalid response', "Search for #{terms}: (#{e})")
      return false
    end
    return false unless json

    return false unless json['resultCount']&amp;.positive?

    result = json['results'][0]
    case entity
    when /movie/
      # dev parameter probably not necessary in this case
      output_url = result['trackViewUrl']
      output_title = result['trackName']
    when /(mac|iPad)Software/
      output_url = dev &amp;&amp; result['sellerUrl'] ? result['sellerUrl'] : result['trackViewUrl']
      output_title = result['trackName']
    when /(musicArtist|song|album)/
      case result['wrapperType']
      when 'track'
        output_url = result['trackViewUrl']
        output_title = "#{result['trackName']} by #{result['artistName']}"
      when 'collection'
        output_url = result['collectionViewUrl']
        output_title = "#{result['collectionName']} by #{result['artistName']}"
      when 'artist'
        output_url = result['artistLinkUrl']
        output_title = result['artistName']
      end
    when /podcast/
      output_url = result['collectionViewUrl']
      output_title = result['collectionName']
    end
    return false unless output_url &amp;&amp; output_title

    return [output_url, output_title] if dev

    [output_url + aff, output_title]
  end

  def lastfm(entity, terms)
    url = URI.parse("http://ws.audioscrobbler.com/2.0/?method=#{entity}.search&amp;#{entity}=#{ERB::Util.url_encode(terms)}&amp;api_key=2f3407ec29601f97ca8a18ff580477de&amp;format=json")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9
    json = JSON.parse(res)
    return false unless json['results']

    begin
      case entity
      when 'track'
        result = json['results']['trackmatches']['track'][0]
        url = result['url']
        title = "#{result['name']} by #{result['artist']}"
      when 'artist'
        result = json['results']['artistmatches']['artist'][0]
        url = result['url']
        title = result['name']
      end
      [url, title]
    rescue StandardError
      false
    end
  end

  def define(terms)
    url = URI.parse("http://api.duckduckgo.com/?q=!def+#{ERB::Util.url_encode(terms)}&amp;format=json&amp;no_redirect=1&amp;no_html=1&amp;skip_disambig=1")
    res = Net::HTTP.get_response(url).body
    res = res.force_encoding('utf-8') if RUBY_VERSION.to_f &gt; 1.9

    result = JSON.parse(res)

    if result
      wiki_link = result['Redirect'] || false
      title = terms

      if !wiki_link.empty? &amp;&amp; !title.empty?
        return [wiki_link, title]
      end
    end

    def_url = "https://www.wordnik.com/words/#{ERB::Util.url_encode(terms)}"
    body = `/usr/bin/curl -sSL '#{def_url}'`
    if body =~ /id="define"/
      first_definition = body.match(%r{(?mi)(?:id="define"[\s\S]*?&lt;li&gt;)([\s\S]*?)&lt;/li&gt;})[1]
      parts = first_definition.match(%r{&lt;abbr title="partOfSpeech"&gt;(.*?)&lt;/abbr&gt; (.*?)$})
      return [def_url, "(#{parts[1]}) #{parts[2]}".gsub(/ *&lt;\/?.*?&gt; /, '')]
    end

    false
  rescue StandardError
    false
  end

  def pinboard_bookmarks
    bookmarks = `/usr/bin/curl -sSL "https://api.pinboard.in/v1/posts/all?auth_token=#{@cfg['pinboard_api_key']}&amp;format=json"`
    bookmarks = bookmarks.force_encoding('utf-8')
    bookmarks.gsub!(/[^[:ascii:]]/) do |non_ascii|
      non_ascii.force_encoding('utf-8')
               .encode('utf-16be')
               .unpack('H*')
               .gsub(/(....)/, '\u\1')
    end

    bookmarks.gsub!(/[\u{1F600}-\u{1F6FF}]/, '')

    bookmarks = JSON.parse(bookmarks)
    updated = Time.now
    { 'update_time' =&gt; updated, 'bookmarks' =&gt; bookmarks }
  end

  def save_pinboard_cache(cache)
    cachefile = PINBOARD_CACHE

    # file = File.new(cachefile,'w')
    # file = Zlib::GzipWriter.new(File.new(cachefile,'w'))
    begin
      File.open(cachefile, 'wb') {|f| f.write(Marshal.dump(cache))}
    rescue IOError
      add_error('Pinboard cache error', 'Failed to write stash to disk')
      return false
    end
    true
  end

  def get_pinboard_cache
    refresh_cache = false
    cachefile = PINBOARD_CACHE

    if File.exist?(cachefile)
      begin
        # file = IO.read(cachefile) # Zlib::GzipReader.open(cachefile)
        # cache = Marshal.load file
        cache = Marshal.load(File.binread(cachefile))
        # file.close
      rescue StandardError
        add_error('Error loading pinboard cache', "StandardError reading #{cachefile}")
        cache = pinboard_bookmarks
        save_pinboard_cache(cache)
      rescue IOError # Zlib::GzipFile::Error
        add_error('Error loading pinboard cache', "IOError reading #{cachefile}")
        cache = pinboard_bookmarks
        save_pinboard_cache(cache)
      end
      updated = JSON.parse(`/usr/bin/curl -sSL 'https://api.pinboard.in/v1/posts/update?auth_token=#{@cfg['pinboard_api_key']}&amp;format=json'`)
      last_bookmark = Time.parse(updated['update_time'])
      if cache&amp;.key?('update_time')
        last_update = cache['update_time']
        refresh_cache = true if last_update &lt; last_bookmark
      else
        refresh_cache = true
      end
    else
      refresh_cache = true
    end

    if refresh_cache
      cache = pinboard_bookmarks
      save_pinboard_cache(cache)
    end

    cache
  end

  # Search pinboard bookmarks
  # Begin query with '' to force exact matching (including description text)
  # Regular matching searches for each word of query and scores the bookmarks
  # exact matches in title get highest score
  # exact matches in description get second highest score
  # other bookmarks are scored based on the number of words that match
  #
  # After sorting by score, bookmarks will be sorted by date and the most recent
  # will be returned
  #
  # Exact matching is case and punctuation insensitive
  def pinboard(terms)
    unless @cfg['pinboard_api_key']
      add_error('Missing Pinboard API token',
                'Find your api key at https://pinboard.in/settings/password and add it
                to your configuration (pinboard_api_key: YOURKEY)')
      return false
    end

    top = nil

    # If search terms start with ''term, only search for exact string matches
    if terms =~ /^ *'/
      exact_match = true
      terms.gsub!(/(^ *'+|'+ *$)/, '')
    else
      exact_match = false
    end

    cache = get_pinboard_cache
    # cache = pinboard_bookmarks
    bookmarks = cache['bookmarks']

    if exact_match
      bookmarks.each do |bm|
        text = [bm['description'], bm['extended'], bm['tags']].join(' ')

        return [bm['href'], bm['description']] if text.matches_exact(terms)
      end

      return false
    else
      matches = []
      bookmarks.each do |bm|
        title_tags = [bm['description'], bm['tags']].join(' ')
        full_text = [bm['description'], bm['extended'], bm['tags']].join(' ')
        score = 0

        score = if title_tags.matches_exact(terms)
                  14.0
                elsif full_text.matches_exact(terms)
                  13.0
                elsif full_text.matches_any(terms)
                  full_text.matches_score(terms)
                else
                  0
                end

        if score == 14
          return [bm['href'], bm['description']]
        elsif score.positive?
          matches.push({
            score: score,
            href: bm['href'],
            title: bm['description'],
            date: bm['time']
          })
        end
      end

      return false if matches.empty?

      top = matches.sort_by { |bm| [bm[:score], bm[:date]] }.last
    end

    return false unless top

    [top[:href], top[:title]]
  end

  # Search bookmark paths and addresses. Return array of bookmark hashes.
  def search_hook(search)
    path_matches = `osascript &lt;&lt;'APPLESCRIPT'
      set searchString to "#{search.strip}"
      tell application "Hook"
        set _marks to every bookmark whose name contains searchString or path contains searchString or address contains searchString
        set _out to {}
        repeat with _hook in _marks
          set _out to _out &amp; (name of _hook &amp; "||" &amp; address of _hook &amp; "||" &amp; path of _hook)
        end repeat
        set {astid, AppleScript's text item delimiters} to {AppleScript's text item delimiters, "^^"}
        set _output to _out as string
        set AppleScript's text item delimiters to astid
        return _output
      end tell
    APPLESCRIPT`.strip.split_hooks

    top_match = path_matches.uniq.first
    return false unless top_match

    [top_match[:url], top_match[:name]]
  end

  def google(terms, define = false)
    uri = URI.parse("http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;filter=1&amp;rsz=small&amp;q=#{ERB::Util.url_encode(terms)}")
    req = Net::HTTP::Get.new(uri.request_uri)
    req['Referer'] = 'http://brettterpstra.com'
    res = Net::HTTP.start(uri.host, uri.port) { |http| http.request(req) }
    body = if RUBY_VERSION.to_f &gt; 1.9
             res.body.force_encoding('utf-8')
           else
             res.body
           end

    json = JSON.parse(body)
    return ddg(terms, false) unless json['responseData']

    result = json['responseData']['results'][0]
    return false if result.nil?

    output_url = result['unescapedUrl']
    output_title = if define &amp;&amp; output_url =~ /dictionary/
                     result['content'].gsub(/&lt;\/?.*?&gt;/, '')
                   else
                     result['titleNoFormatting']
                   end
    [output_url, output_title]
  rescue StandardError
    ddg(terms, false)
  end

  def ddg(terms, type = false)
    prefix = type ? "#{type.sub(/^!?/, '!')} " : '%5C'
    begin
      cmd = %(/usr/bin/curl -LisS --compressed 'https://lite.duckduckgo.com/lite/?q=#{prefix}#{ERB::Util.url_encode(terms)}')
      body = `#{cmd}`
      locs = body.force_encoding('utf-8').scan(/^location: (.*?)$/)
      return false if locs.empty?

      url = locs[-1]

      result = url[0].strip || false
      return false unless result

      output_url = CGI.unescape(result)
      output_title = if @cfg['include_titles'] || @titleize
                       titleize(output_url) || ''
                     else
                       ''
                     end
      [output_url, output_title]
    end
  end

  def titleize(url)
    title = nil

    gather = false
    ['/usr/local/bin', '/opt/homebrew/bin'].each do |root|
      if File.exist?(File.join(root, 'gather')) &amp;&amp; File.executable?(File.join(root, 'gather'))
        gather = File.join(root, 'gather')
        break
      end
    end

    return `#{gather} --title-only '#{url.strip}'` if gather

    begin
      # source = %x{/usr/bin/curl -sSL '#{url.strip}'}

      uri = URI.parse(url)
      res = Net::HTTP.get_response(uri)

      if res.code.to_i == 200
        source = res.body
        title = source ? source.match(%r{&lt;title&gt;(.*)&lt;/title&gt;}im) : nil

        title = title.nil? ? nil : title[1].strip
      end

      if title.nil? || title =~ /^\s*$/
        warn "Warning: missing title for #{url.strip}"
        title = url.gsub(%r{(^https?://|/.*$)}, '').gsub(/-/, ' ').strip
      else
        title = title.gsub(/\n/, ' ').gsub(/\s+/, ' ').strip # .sub(/[^a-z]*$/i,'')
      end

      # Skipping SEO removal until it's more reliable
      # title.remove_seo(url.strip)
      title
    rescue StandardError =&gt; e
      warn "Error retrieving title for #{url.strip}"
      raise e
    end
  end

  def spell(phrase)
    aspell = if File.exist?('/usr/local/bin/aspell')
               '/usr/local/bin/aspell'
             elsif File.exist?('/opt/homebrew/bin/aspell')
               '/opt/homebrew/bin/aspell'
             end

    if aspell.nil?
      add_error('Missing aspell', 'Install aspell in to allow spelling corrections')
      return false
    end

    words = phrase.split(/\b/)
    output = ''
    words.each do |w|
      if w =~ /[A-Za-z]+/
        spell_res = `echo "#{w}" | #{aspell} --sug-mode=bad-spellers -C pipe | head -n 2 | tail -n 1`
        if spell_res.strip == "\*"
          output += w
        else
          spell_res.sub!(/.*?: /, '')
          results = spell_res.split(/, /).delete_if { |word| phrase =~ /^[a-z]/ &amp;&amp; word =~ /[A-Z]/ }
          output += results[0]
        end
      else
        output += w
      end
    end
    output
  end

  def amazon_affiliatize(url, amazon_partner)
    return url if amazon_partner.nil? || amazon_partner.empty?

    return [url, ''] unless url =~ %r{https?://(?:.*?)amazon.com/(?:(.*?)/)?([dg])p/([^?]+)}

    m = Regexp.last_match
    title = m[1]
    type = m[2]
    id = m[3]
    az_url = "http://www.amazon.com/#{type}p/product/#{id}/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=ll1&amp;tag=#{amazon_partner}"
    [az_url, title]
  end

  def template_social(user, url, service)
    template = @cfg['social_template']
    template.sub!(/%user%/, user)
    template.sub!(/%service%/, service)
    template.sub!(/%url%/, url.sub(%r{^https?://(www\.)?}, '').sub(%r{/$}, ''))
    template
  end

  def social_handle(type, term)
    handle = term.sub(/^@/, '').strip
    case type
    when /^t/
      url = "https://twitter.com/#{handle}"
      title = template_social(handle, url, 'Twitter')
    when /^f/
      url = "https://www.facebook.com/#{handle}"
      title = template_social(handle, url, 'Facebook')
    when /^l/
      url = "https://www.linkedin.com/in/#{handle}/"
      title = template_social(handle, url, 'LinkedIn')
    when /^i/
      url = "https://www.instagram.com/#{handle}/"
      title = template_social(handle, url, 'Instagram')
    when /^m/
      parts = handle.split(/@/)
      return [false, term] unless parts.count == 2

      url = "https://#{parts[1]}/@#{parts[0]}"
      title = template_social(handle, url, 'Mastodon')
    else
      [false, term]
    end
    [url, title]
  end

  def do_search(search_type, search_terms, link_text = '', search_count = 0)
    if (search_count % 5).zero?
      notify('Throttling for 5s')
      sleep 5
    end

    notify('Searching', search_terms)
    return [false, search_terms, link_text] if search_terms.empty?

    case search_type
    when /^r$/ # simple replacement
      if @cfg['validate_links'] &amp;&amp; !valid_link?(search_terms)
        return [false, "Link not valid: #{search_terms}", link_text]
      end

      link_text = search_terms if link_text == ''
      return [search_terms, link_text, link_text]
    when /^@t/ # twitter-ify username
      unless search_terms.strip =~ /^@?[0-9a-z_$]+$/i
        return [false, "#{search_terms} is not a valid Twitter handle", link_text]
      end

      url, title = social_handle('t', search_terms)
      link_text = title
    when /^@fb?/ # fb-ify username
      unless search_terms.strip =~ /^@?[0-9a-z_]+$/i
        return [false, "#{search_terms} is not a valid Facebook username", link_text]
      end

      url, title = social_handle('f', search_terms)
      link_text = title
    when /^@i/ # intagramify username
      unless search_terms.strip =~ /^@?[0-9a-z_]+$/i
        return [false, "#{search_terms} is not a valid Instagram username", link_text]
      end

      url, title = social_handle('i', search_terms)
      link_text = title
    when /^@l/ # linked-inify username
      unless search_terms.strip =~ /^@?[0-9a-z_]+$/i
        return [false, "#{search_terms} is not a valid LinkedIn username", link_text]
      end

      url, title = social_handle('l', search_terms)
      link_text = title
    when /^@m/ # mastodonify username
      unless search_terms.strip =~ /^@?[0-9a-z_]+@[0-9a-z_.]+$/i
        return [false, "#{search_terms} is not a valid Mastodon username", link_text]
      end

      url, title = social_handle('m', search_terms)
      link_text = title
    when /^sp(ell)?$/ # replace with spelling suggestion
      res = spell(search_terms)
      return [res, res, ''] if res

      url = false
    when /^hook$/
      url, title = search_hook(search_terms)
    when /^h(([scf])([hb])?)*$/
      mtch = Regexp.last_match(1)
      str = mtch
      types = []
      if str =~ /s([hb]*)/
        t = Regexp.last_match(1)
        if t.length &gt; 1
          types.push('safari_history')
          types.push('safari_bookmarks')
        elsif t == 'h'
          types.push('safari_history')
        elsif t == 'b'
          types.push('safari_bookmarks')
        end
      end

      if str =~ /c([hb]*)/
        t = Regexp.last_match(1)
        if t.length &gt; 1
          types.push('chrome_bookmarks')
          types.push('chrome_history')
        elsif t == 'h'
          types.push('chrome_history')
        elsif t == 'b'
          types.push('chrome_bookmarks')
        end
      end

      if str =~ /f([hb]*)/
        t = Regexp.last_match(1)
        if t.length &gt; 1
          types.push('firefox_bookmarks')
          types.push('firefox_history')
        elsif t == 'h'
          types.push('firefox_history')
        elsif t == 'b'
          types.push('firefox_bookmarks')
        end
      end

      if str =~ /e([hb]*)/
        t = Regexp.last_match(1)
        if t.length &gt; 1
          types.push('edge_bookmarks')
          types.push('edge_history')
        elsif t == 'h'
          types.push('edge_history')
        elsif t == 'b'
          types.push('edge_bookmarks')
        end
      end

      if str =~ /b([hb]*)/
        t = Regexp.last_match(1)
        if t.length &gt; 1
          types.push('brave_bookmarks')
          types.push('brave_history')
        elsif t == 'h'
          types.push('brave_history')
        elsif t == 'b'
          types.push('brave_bookmarks')
        end
      end

      url, title = search_history(search_terms, types)
    when /^a$/
      az_url, = ddg("site:amazon.com #{search_terms}")
      url, title = amazon_affiliatize(az_url, @cfg['amazon_partner'])
    when /^(g|ddg)$/ # google lucky search
      url, title = ddg(search_terms)
    when /^z(ero)?/
      url, title = zero_click(search_terms)
    when /^yt$/
      url, title = ddg("site:youtube.com #{search_terms}")
    when /^pb$/
      url, title = pinboard(search_terms)
    when /^wiki$/
      url, title = wiki(search_terms)
    when /^def$/ # wikipedia/dictionary search
      # title, definition, definition_link, wiki_link = zero_click(search_terms)
      # if search_type == 'def' &amp;&amp; definition_link != ''
      #   url = definition_link
      #   title = definition.gsub(/'+/,"'")
      # elsif wiki_link != ''
      #   url = wiki_link
      #   title = "Wikipedia: #{title}"
      # end
      fix = spell(search_terms)

      if fix &amp;&amp; search_terms.downcase != fix.downcase
        add_error('Spelling', "Spelling altered for '#{search_terms}' to '#{fix}'")
        search_terms = fix
        link_text = fix
      end

      url, title = define(search_terms)
    when /^imov?$/ # iTunes movie search
      dev = false
      url, title = itunes('movie', search_terms, dev, @cfg['itunes_affiliate'])
    when /^masd?$/ # Mac App Store search (mas = itunes link, masd = developer link)
      dev = search_type =~ /d$/
      url, title = itunes('macSoftware', search_terms, dev, @cfg['itunes_affiliate'])

    when /^itud?$/ # iTunes app search
      dev = search_type =~ /d$/
      url, title = itunes('iPadSoftware', search_terms, dev, @cfg['itunes_affiliate'])

    when /^s$/ # software search (google)
      excludes = %w[postmates.com download.cnet.com softpedia.com softonic.com macupdate.com]
      url, title = ddg(%(#{excludes.map { |x| "-site:#{x}" }.join(' ')} #{search_terms} (app OR mac)))
      link_text = title if link_text == '' &amp;&amp; !@titleize
    when /^tmdb/
      url, title = tmdb(search_type, search_terms)
      link_text = title if link_text == '' &amp;&amp; !@titleize
    when /^am/ # apple music search
      stype = search_type.downcase.sub(/^am/, '')
      otype = 'link'
      if stype =~ /e$/
        otype = 'embed'
        stype.sub!(/e$/, '')
      end
      result = case stype
               when /^pod$/
                 applemusic(search_terms, 'podcast')
               when /^art$/
                 applemusic(search_terms, 'music', 'musicArtist')
               when /^alb$/
                 applemusic(search_terms, 'music', 'album')
               when /^song$/
                 applemusic(search_terms, 'music', 'musicTrack')
               else
                 applemusic(search_terms)
               end

      return [false, "Not found: #{search_terms}", link_text] unless result

      # {:type=&gt;,:id=&gt;,:url=&gt;,:title=&gt;}
      if otype == 'embed' &amp;&amp; result[:type] =~ /(album|song)/
        url = 'embed'
        if result[:type] =~ /song/
          link = %(https://embed.music.apple.com/#{@cfg['country_code'].downcase}/album/#{result[:album]}?i=#{result[:id]}&amp;app=music#{@cfg['itunes_affiliate']})
          height = 150
        else
          link = %(https://embed.music.apple.com/#{@cfg['country_code'].downcase}/album/#{result[:id]}?app=music#{@cfg['itunes_affiliate']})
          height = 450
        end

        title = [
          %(&lt;iframe src="#{link}" allow="autoplay *; encrypted-media *;"),
          %(frameborder="0" height="#{height}"),
          %(style="width:100%;max-width:660px;overflow:hidden;background:transparent;"),
          %(sandbox="allow-forms allow-popups allow-same-origin),
          %(allow-scripts allow-top-navigation-by-user-activation"&gt;&lt;/iframe&gt;)
        ].join(' ')
      else
        url = result[:url]
        title = result[:title]
      end

    when /^ipod$/
      url, title = itunes('podcast', search_terms, false)

    when /^isong$/ # iTunes Song Search
      url, title = itunes('song', search_terms, false)

    when /^iart$/ # iTunes Artist Search
      url, title = itunes('musicArtist', search_terms, false)

    when /^ialb$/ # iTunes Album Search
      url, title = itunes('album', search_terms, false)

    when /^lsong$/ # Last.fm Song Search
      url, title = lastfm('track', search_terms)

    when /^lart$/ # Last.fm Artist Search
      url, title = lastfm('artist', search_terms)
    else
      if search_terms
        if search_type =~ /.+?\.\w{2,4}$/
          url, title = ddg(%(site:#{search_type} #{search_terms}))
        else
          url, title = ddg(search_terms)
        end
      end
    end

    if link_text == ''
      link_text = @titleize ? title : search_terms
    end

    if url &amp;&amp; @cfg['validate_links'] &amp;&amp; !valid_link?(url) &amp;&amp; search_type !~ /^sp(ell)?/
      [false, "Not found: #{url}", link_text]
    elsif !url
      [false, "No results: #{url}", link_text]
    else
      [url, title, link_text]
    end
  end
end

sl = SearchLink.new({ echo: false })
overwrite = true
backup = sl.cfg['backup']

if !ARGV.empty?
  files = []
  ARGV.each do |arg|
    case arg
    when /^(--?)?(h(elp)?|v(ersion)?)$/
      $stdout.puts "SearchLink v#{VERSION}"
      sl.help_cli
      $stdout.puts 'See http://brettterpstra.com/projects/searchlink/ for help'
      Process.exit
    when /^--?(stdout)$/
      overwrite = false
    when /^--?no[\-_]backup$/
      backup = false
    else
      files.push(arg)
    end
  end

  files.each do |file|
    if File.exist?(file) &amp;&amp; `file -b "#{file}"|grep -c text`.to_i.positive?
      input = RUBY_VERSION.to_f &gt; 1.9 ? IO.read(file).force_encoding('utf-8') : IO.read(file)

      FileUtils.cp(file, "#{file}.bak") if backup &amp;&amp; overwrite

      sl.parse(input)

      if overwrite
        File.open(file, 'w') do |f|
          f.puts sl.output
        end
      else
        puts sl.output
      end
    else
      warn "Error reading #{file}"
    end
  end
else
  input = RUBY_VERSION.to_f &gt; 1.9 ? $stdin.read.force_encoding('utf-8').encode : $stdin.read

  sl.parse(input)
  if sl.clipboard
    print input
  else
    print sl.output
  end
end
</string>
					<key>CheckedForUserDefaultShell</key>
					<true/>
					<key>inputMethod</key>
					<integer>0</integer>
					<key>shell</key>
					<string>/usr/bin/ruby</string>
					<key>source</key>
					<string></string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.3</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>InputUUID</key>
				<string>1B92DCEB-5863-44D2-BBFD-E97F0318316D</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>34FFFEE7-9E94-42F4-89C2-2F66196FF67A</string>
				<key>UUID</key>
				<string>348C55FD-D93F-4CDE-A8A8-DC31888F8448</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>724.500000:305.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
	</array>
	<key>connectors</key>
	<dict/>
	<key>workflowMetaData</key>
	<dict>
		<key>applicationBundleIDsByPath</key>
		<dict/>
		<key>applicationPaths</key>
		<array/>
		<key>backgroundColor</key>
		<data>
		YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9i
		amVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGpCwwXGBki
		KCkwVSRudWxs1Q0ODxAREhMUFRZWJGNsYXNzW05TQ29sb3JOYW1lXE5TQ29s
		b3JTcGFjZV1OU0NhdGFsb2dOYW1lV05TQ29sb3KACIADEAaAAoAEVlN5c3Rl
		bV8QEXN5c3RlbVB1cnBsZUNvbG9y1RobDxwNHR4fIBJcTlNDb21wb25lbnRz
		VU5TUkdCXxASTlNDdXN0b21Db2xvclNwYWNlSzAuNSAwIDAuNSAxTxAcMC40
		MTgxOTMzOTk5IDAgMC40MjQzMDUzMTk4ABABgAWACNMjJA0lJidUTlNJRFVO
		U0lDQxAHgAaAB08RDEgAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkA
		BgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAAAA9tYAAQAA
		AADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0AAAB8AAA
		ABRia3B0AAACBAAAABRyWFlaAAACGAAAABRnWFlaAAACLAAAABRiWFlaAAAC
		QAAAABRkbW5kAAACVAAAAHBkbWRkAAACxAAAAIh2dWVkAAADTAAAAIZ2aWV3
		AAAD1AAAACRsdW1pAAAD+AAAABRtZWFzAAAEDAAAACR0ZWNoAAAEMAAAAAxy
		VFJDAAAEPAAACAxnVFJDAAAEPAAACAxiVFJDAAAEPAAACAx0ZXh0AAAAAENv
		cHlyaWdodCAoYykgMTk5OCBIZXdsZXR0LVBhY2thcmQgQ29tcGFueQAAZGVz
		YwAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAABJzUkdCIElF
		QzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPNRAAEAAAABFsxYWVogAAAAAAAA
		AAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3
		hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z2Rlc2MAAAAAAAAAFklFQyBodHRw
		Oi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5j
		aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AABkZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91
		ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1
		bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGlu
		IElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENv
		bmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		AAAAAHZpZXcAAAAAABOk/gAUXy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAA
		AAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAA
		Ao8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4A
		IwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQ
		AJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEB
		BwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGa
		AaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQC
		XQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOAND
		A08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUE
		YwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWm
		BbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkH
		Kwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjS
		COcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4K
		xQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZ
		DPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUP
		QQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJ
		EegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsU
		rRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReu
		F9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwb
		FBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6U
		Hr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUi
		giKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaH
		Jrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8r
		Ais2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+R
		L8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0
		njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8
		Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/
		YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUS
		RVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxL
		U0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGb
		UeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9Y
		fVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19h
		X7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm
		6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5r
		bsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52
		m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7C
		fyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuH
		n4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBu
		kNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ
		/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2
		o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUSt
		uK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfg
		uFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C
		28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21
		zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZ
		bNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T8
		5YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXx
		cvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26
		/kv+3P9t///SKissLVokY2xhc3NuYW1lWCRjbGFzc2VzXE5TQ29sb3JTcGFj
		ZaIuL1xOU0NvbG9yU3BhY2VYTlNPYmplY3TSKisxMldOU0NvbG9yojEvAAgA
		EQAaACQAKQAyADcASQBMAFEAUwBdAGMAbgB1AIEAjgCcAKQApgCoAKoArACu
		ALUAyQDUAOEA5wD8AQgBJwEpASsBLQE0ATkBPwFBAUMBRQ2RDZYNoQ2qDbcN
		ug3HDdAN1Q3dAAAAAAAAAgEAAAAAAAAAMwAAAAAAAAAAAAAAAAAADeA=
		</data>
		<key>backgroundColorName</key>
		<string>systemPurpleColor</string>
		<key>customImageFileData</key>
		<data>
		iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAEumlUWHRYTUw6
		Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJX
		NU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4
		PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgog
		PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAy
		LzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjph
		Ym91dD0iIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9l
		eGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29t
		L3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFk
		b2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDov
		L25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRw
		Oi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9
		Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2
		ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjY0IgogICBleGlmOlBp
		eGVsWURpbWVuc2lvbj0iNjQiCiAgIGV4aWY6Q29sb3JTcGFjZT0iMSIKICAg
		dGlmZjpJbWFnZVdpZHRoPSI2NCIKICAgdGlmZjpJbWFnZUxlbmd0aD0iNjQi
		CiAgIHRpZmY6UmVzb2x1dGlvblVuaXQ9IjIiCiAgIHRpZmY6WFJlc29sdXRp
		b249IjcyLjAiCiAgIHRpZmY6WVJlc29sdXRpb249IjcyLjAiCiAgIHBob3Rv
		c2hvcDpDb2xvck1vZGU9IjMiCiAgIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJz
		UkdCIElFQzYxOTY2LTIuMSIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjAtMDEt
		MDdUMDI6NDA6MjItMDY6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjAt
		MDEtMDdUMDI6NDA6MjItMDY6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAg
		IDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJw
		cm9kdWNlZCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWZmaW5pdHkg
		RGVzaWduZXIgKFNlcCAyMiAyMDE5KSIKICAgICAgc3RFdnQ6d2hlbj0iMjAy
		MC0wMS0wN1QwMjo0MDoyMi0wNjowMCIvPgogICAgPC9yZGY6U2VxPgogICA8
		L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpS
		REY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+GQoLqgAAAYFp
		Q0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZG/S0JRFMc/WmGUYVBDQ4OENWmY
		gtQSpEQFEmIGWS36/BWoPd4zIlqDVqEgaunXUH9BrUFzEBRFEE0NzUUtJa/z
		MlAiz+He+7nfe87h3nPBGssrBb3ZC4ViSYtOBJ1z8Xmn7RkLNvFu/AlFV8ci
		kTAN7eNOosVuPGatxnH/WnsqrStgaRUeVVStJDwpHF4tqSZvC3cruURK+FTY
		rckFhW9NPVnlF5OzVf4yWYtFQ2DtFHZm6zhZx0pOKwjLy3EV8ivK733Ml9jT
		xdkZWftk9KITZYIgTqYYJ0SAIUZkDuDBx6DsaJDv/cmfZllyFZlV1tBYIkuO
		Em5RV6R6WtaM6GnxPGtm///2Vc/4fdXq9iC0PBnGWz/YtqBSNozPQ8OoHEHT
		I1wUa/nLBzD8Lnq5prn2wbEBZ5c1LbkD55vQ86AmtMSP1CTDmsnA6wl0xKHr
		GtoWqj37Pef4HmLr8lVXsLsHAxLvWPwGMBxnzYSHYMEAAAAJcEhZcwAACxMA
		AAsTAQCanBgAAAbFSURBVHic7ZtZjBZFEMd/DLsseIMsK6xyqgjIuSuJ1wsh
		kQRBQUBROVQ8MB4kGvHiQROFiAm+qDEoagLEYxF9AB9U4oMmoqBcYiQCuiBG
		YJcrCrssfD7UjNMz2zPfdE9/ZBX+SWdnp6qrqmt6qruq54MzOL3RrkRy2wOX
		A4P9/zcD24ATBjLKgP7+9c9AizPrSggPeBQ4BBRi7ZBP84rIGA18CzQpfZv8
		e6NLYrUjnA+spfXA420tUKHp7wHvZOj/LlBeumHY43GKGx+0sZr+owz63+PK
		6GLT0QQzDHjP0ty70KD/3Qa8qXDlgFrgSkeysuAawgCZC64cMNORHBPc5UKI
		Cwd0AKY6kGOK6chymwsuHDAe6OJAjim6A2PyCnHhgJkOZNgidzDM64CLcPAU
		cmAc0DWPgLwOmIaD9zAHyoE78wjI6wCTtb9UyLUa5HHAFGBQHuWOMASYZNvZ
		1gETgKW2SkuA5cDNNh1tHDABeJ+2lZCUAx9g4QRTB7TFwQewcoKJAwbTdgcf
		IHBC5rzEZAlbCIwwtUjBDuBTYDGwGvgrRm8A6oGDwDlAZ0s97ZFs8xPL/lpU
		AsfInq8H7RjwGtDbQmcf4HWilSETvZUWOhPxrIURy4EeCfJ0tcik+mQ18J6F
		/qcNxpeKMuB3Q+VLYgPqhGxYlgE70a/bk3zacp+3o0LzgLcNbdjl254btxkq
		/owwuLYDngT2xXgma/RMjvHsA+YSOtLzZZvYMiX36IGvDZWq2+O6BJ4sDgha
		ncIzw9CWr3KMG4AaQ4UFJEMEuDqFx8QBBV8WQJWFPcPTBlhsH/BIEboONwJn
		I9PXFeb6MsdZ9LUZA2C/9BWA5iJ00xmQRWZSS10S02bA/egPMLKgFLtFW5kV
		wH1JxCQHlAGzLRW2RcwmYUlMcsAtJG9i/ouoBibqCEkOsA4cbRjaMekcUIOc
		vPzfcC2aZE7ngCxPvxnYBDTmNMoFGhFbmjPwPhy/EQ8MlcCtmo4HgQ+BdX7b
		oijsg5wN1iCnvqU+I9wCrALW+7bs9O938HXX+m0ycEGs71TgCWSbrYUu61tN
		9oBYBsyjdPuAeWRPcKqR+kNczjNpxqtZ3yH05/D9kFnyHMkFkmHAxpTBmDpg
		AzA0xt8BuAp4AEm4ko7nZgGHFVm7SXCimmg0An0VWnvEc40xw3YkKAXZuKxK
		GJCJA1YR3QR1B1bSulCyIMWWvsABhXe6ztjtCsMdCm0A8n2OzrjFKUoDYxs0
		/bI6oIEwuQI5BYo/hAJSXrupiC3TFP7txGbBfQrxI+X+UOCoQtsLzEc2SpcU
		URjgdo3BWR2gHrvH49M3SEAbBZyb0ZaPlf73BjcrkGJkAYmO3fz75ci7F3So
		w77OtgJzB6h1gOGEgfUo8Bh2ZxpVwH5fTj1+rjNeUTpfYX5eub/MQpmKEZg7
		IMjjOxANqFYnQAoWKLLGe0TX7XX+3wrCfP4P4KGcSjcjQSsrmpD1HmTAQ/zr
		pcg0zoN1yvVADwlyceJQxPMAi5AImgfHESdkxSa/D8hSF2BeTjtANlABBnrA
		QP+f/cBv/nWtwvSdA6UQ9bwJb2DLfuBXB3bsRFYXgAEe4edmGxSmYNNxAvje
		gVJicgoaunrvB40trh6EKr+/R7inVyN8cHS1BNlFuUCVct2goauJVTfleoVv
		yxuO7FBtaQYJNgXknVMPI1yXtdQ1+AoNfYBCXxmjubSlE/LleQHY7CEnKCA7
		o2EK43HcIniXC0jOEcduwtegNkZzactwwkPhXR6wRiHWOFSkogrJzkDe5SMa
		niOEwe9ioq+BS6hjXOMRXVdL9cmbKjft2FqlnQpb/h37etJ3aXnQjfBssAW4
		NIX3MsL3cy+Oj7iRND4YZ2RZHqMQ1HzABdQ84M0M/G8p/HVFeE2g5gEF4IY4
		wxckR2FbqJng34RxIA3VPq8uI8wDdRX6XMfQG5l2AdMiosuiKSYSLULMMOir
		FmcOkFDTz4iOyFjUlL5XEvP1ROt5W4GRhgq7IB85qJndQlOrgZdjMpZh/lX6
		SOAnRUYTcF2xTmOJ1tBagBcoHpA6Ik9qT8zwRdjl7h7wSkzWHl9HsZlZCbxI
		GFALyJha/VYp6bucQciS1C92v56wNL4R6ElYhh5EtMzUDDyIBLU8mAW8Spid
		ggzsR8WWeiRnCGzpGZOxHal7bDVR3An50Ej3G8C0dhL5qKlva5HW6OfLPGlo
		y0HgKX8s1ugKzAG+JDql4m0b8BLR7bRrDEPiybYUO1p8W+eQ4Zdopj+d7Yxs
		ZLoj6+ph5L2sJ6wlnCr0QqZ6D+A84E+kevUL+Qs4Z3Da4B8YvfYZh3T4jQAA
		AABJRU5ErkJggg==
		</data>
		<key>customImageFileExtension</key>
		<string>png</string>
		<key>inputTypeIdentifier</key>
		<string>com.apple.Automator.text</string>
		<key>outputTypeIdentifier</key>
		<string>com.apple.Automator.text</string>
		<key>presentationMode</key>
		<integer>11</integer>
		<key>processesInput</key>
		<false/>
		<key>serviceInputTypeIdentifier</key>
		<string>com.apple.Automator.text</string>
		<key>serviceOutputTypeIdentifier</key>
		<string>com.apple.Automator.text</string>
		<key>serviceProcessesInput</key>
		<false/>
		<key>useAutomaticInputType</key>
		<false/>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.servicesMenu</string>
	</dict>
</dict>
</plist>
